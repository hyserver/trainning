###1. bashrc与环境变量:
####a. bash的系统和个人配置文件的路径是什么?

- bash配置文件路径为：
<pre><code style="color: #000000;">系统：/etc/profile
用户：~/.bashrc、~/.profile
</pre></code>

####b. $PS1这个环境变量有什么用?
- linux下环境变量PS1简单来说就是设置命令提示符显示的内容，如下：

<pre><code style="color: #000000;">hy@debian:/mnt$ 

PS1变量中提示符各项含义:

\d ：代表日期，格式为weekday month date，例如：Wed Dec 12
\H ：完整的主机名称。例如：hostname是debian.linux
\h ：仅取主机的第一个名字，如上例，则为debian，.linux则被省略
\t ：显示时间为24小时格式，如：HH：MM：SS
\T ：显示时间为12小时格式
\A ：显示时间为24小时格式：HH：MM
\u ：当前用户的账号名称 如：root
\v ：BASH的版本信息  如:3.2
\w ：完整的工作目录名称。家目录会以 ~代替 如显示/etc/default/
\W ：利用basename取得工作目录名称，所以只会列出最后一个目录 如上例则只显示default
\# ：下达的第几个命令
\$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$

简单的设置：
hy@debian:~$ PS1='[\u@\h \w \A #\#]\$'
[hy@debian ~ 23:25 #13]$
如何写进配置文件，让系统在开机的时候生效，一般我们会写进~/.bashrc或者~/.profile
</pre></code>
####c. 在什么情况下需要修改$PATH, 应该如何合理地修改它?
一般情况下，当我们在配置了相关软件后，需要系统能够有该软件所需要的命令的时候，添加环境变量，修改或添加环境变量可以分为两种不同情况：
<pre><code style="color: #000000;">系统环境变量的修改：/etc/bashr或/etc/profile
用户环境变量的设置：可以在~/.bashrc、~/.profile中设置
</pre></code>
####d. 修改过~/.bashrc后, 如何让改变立即生效?
有几种不同的方法：
<pre><code style="color: #000000;">. ~/.bashrc
或者
source ~/.bashrc
</pre></code>
####e. bashrc与profile有什么异同点? 两者的加载顺序如何?


- /etc/bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.
- /etc/profile:此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.
- 在系统开机的时候会先加载/etc/profile，然后再加载/etc/bashrc
- 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是"父子"关系.

###2. FHS与proc:
####a. 为什么系统命令会分别放到/bin, /sbin, /usr/bin, /usr/sbin这四个目录中? 这些目录间有什么区别?
<p>Linux中的绝大多数命令都是放在上面四个（/bin, /sbin, /usr/bin, /usr/sbin）目录当中的，Linux中所有的命令都都是可执行的二进制文件（binary）。</p>

<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td style="text-align: center;" width="140">
<p><strong>目录名</strong></p>
</td>
<td width="730">
<p style="text-align: center;"><strong>目录作用</strong></p>
</td>
</tr>
<tr>
<td width="140">
<p style="text-align: center;">/bin/</p>
</td>
<td width="730">
<p>存放系统命令的目录，<span style="color: #0000ff;">普通用户和超级用户</span>都可以执行。不过放在/bin下的命令在单用户模式下也可以执行</p>
</td>
</tr>
<tr>
<td width="140">
<p style="text-align: center;">/sbin/</p>
</td>
<td width="730">
<p>保存和系统环境设置相关的命令，<span style="color: #0000ff;">只有超级用户</span>可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看</p>
</td>
</tr>
<tr>
<td width="140">
<p style="text-align: center;">/usr/bin/</p>
</td>
<td width="730">
<p>存放系统命令的目录，<span style="color: #0000ff;">普通用户和超级用户</span>都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</p>
</td>
</tr>
<tr>
<td width="140">
<p style="text-align: center;">/usr/sbin/</p>
</td>
<td width="730">
<p>存放根文件系统不必要的系统管理命令，例如多数服务程序。<span style="color: #0000ff;">只有超级用户</span>可以使用。大家其实可以注意到Linux的系统，在所有“sbin”目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用</p>
</td>
</tr>
</tbody>
</table>
####b. /var目录通常用来放哪些内容? /var和/tmp有什么区别?
- /var：动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件
- /tmp也是保存临时文件，动态数据的，但/tmp中的文件可以随时清空
####c. /boot目录里有哪些内容?
<p>系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序（grub）文件等。</p>
####d. /usr/include和/usr/lib有什么区别?
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td style="text-align: center;" width="140">
<p><strong>目录名</strong></p>
</td>
<td width="730">
<p style="text-align: center;"><strong>目录作用</strong></p>
</td>
</tr>
<tr>
<td width="140">
<p style="text-align: center;">/usr/include/</p>
</td>
<td width="730">
<p>c/c++等程序诧觊的档头(header)不包吨档(include)放置处，当我们以 tarball 方
式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的讲多包吨档喔！</p>
</td>
</tr>
<tr>
<td width="140">
<p style="text-align: center;">/usr/lib/</p>
</td>
<td width="730">
<p>包括各应用软件的函式库、目标档案(object file)，以及不被一般使用者惯用的执行档或脚本(script)。某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作，那就会被摆放到这个目录下啦。要注意的是，如果你使用的是 X86_64 的 Linux 系统， 那可能会有/usr/lib64/目录产生</p>
</td>
</tr>
</td>
</tr>
</tbody>
</table>
####e. /proc目录下的那些数字是什么东西?
<p>/proc：他放置的数据都是在内存当中，那些数字系统核心、行程信息(process)、周边装置的状态及网络状态等等。</p>
####f. 如何在proc文件系统中查看CPU和内存信息?
- 查看cpu信息：cat /proc/cpuinfo
- 查看内存信息：cat /proc/meminfo
###3. cron:
####a. 系统配置文件的路径是什么?
- 全局性配置文件路径：/etc/crontab
- 用户自身的cron 配置文件路径：debian中存放于/var/spool/cron/crontabs/user
####b. cron时间描述里的'-'是什么意思, '/'是什么意思?
- '-'是指从什么时候到什么时候，例如：在上午8点到11点的第3和第15分钟执行
3,15 8-11 * * * myCommand
- '/'是指每隔多长时间执行一次，例如：每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 */2  *  * myCommand
####c. @reboot会在什么时候执行?
- 只是在系统启动后，单次执行一个命令，可以使用 @reboot 宏（仅仅重启 cron 命令不会触发使用@reboot调度的命令）。该宏表示了 crontab条目的前五个区段。
####d. cron的最小粒度是分钟, 如何用cron实现每分钟跑两次(例如, 分别在第0秒和第30秒)运行的任务?
可以使用循环语句，例如：
<pre><code style="color: #000000;">* * * * * for i in `seq 2`;do echo hello ;sleep 30 ;done
</pre></code>
###4. NTP与UTC:
####a. ntpdate和ntpd相比有什么优势和劣势.
- 1.ntpd在实际同步时间时是一点点的校准过来时间的，最终把时间慢慢的校正对。ntpdate不会考虑其他程序是否会阵痛，直接调整时间.一个是校准，一个是调整。
- 2.使用ntpd还需要考虑到一个细节是，如果client与server时差异常大或过小，ntpd将会拒绝server参考时间。 另外还有个未经证实的经验，在服务器压力特别大的情况下，ntpdate会把时间对错。
- 3.用ntpdate调整时间的方式，会有几个非常明显的问题：
	- 1）这样做不安全。ntpdate的设置依赖于ntp服务器的安全性，攻击者可以利用一些软件设计上的缺陷，拿下ntp服务器并令与其同步的服务器执行某些消耗性的任务。由于ntpdate采用的方式是跳变，跟随它的服务器无法知道是否发生了异常（时间不一样的时候，唯一的办法是以服务器为准）。
	- 2）这样做不精确。一旦ntp服务器宕机，跟随它的服务器也就会无法同步时间。与此不同，ntpd不仅能够校准计算机的时间，而且能够校准计算机的时钟。
	- 3）这样做不够优雅。由于是跳变，而不是使时间变快或变慢，依赖时序的程序会出错（例如，如果ntpdate发现你的时间快了，则可能会经历两个相同的时刻，对某些应用而言，这是致命的）。
	- 因而，唯一一个可以令时间发生跳变的点，是计算机刚刚启动，但还没有启动很多服务的那个时候。其余的时候，理想的做法是使用ntpd来校准时钟，而不是调整计算机时钟上的时间。
	- NTPD 在和时间服务器的同步过程中，会把 BIOS 计时器的振荡频率偏差??或者说 Local Clock 的自然漂移(drift)??记录下来。这样即使网络有问题，本机仍然能维持一个相当精确的走时。
####b. 既然已经有了ntp, 为什么还需要有hwclock?
<p>我们完成了Linux的时间更新后，我们需要更新BIOS的时间，因为每一次的重新启动，系统会重新读取BIOS。</p>
####c. UTC是什么?
<p>UTC是国际时,UTC+8就是国际时加八小时,是东八区时间,也就是北京时间.</p>
####d. Debian中如何修改系统时区?
<p>文本方法：</p>
<pre><code style="color: #000000;">第一种：使用tzselect 命令修改时区
第二种：直接编辑配置文件：
vim /etc/timezone
Asia/Shanghai
</pre></code>
###5. 硬链接与软链接:假设 B 是 A 的(软/硬)链接文件, 回答下列问题
####a. 对于硬链接和软链接, 比较当A或者B被删除时, 各有什么后果.
如果B是A的软链接：软链接也称为符号链接，只保留了源文件的路径，删除B后A不会有任何影响，删除A后B所指向的文件将不存在，他就相当于只保留了一个快捷方式，但是源文件不存在了。
如果B是A的硬链接：删除B或者A对另外一个都没任何影响，只会把更新节点计数值减一。
####b. 比较创建硬链接和软链接, 各需要多少硬盘空间?
创建硬链接是直接建立在节点表上的（inode）需要的磁盘空间和源文件大小相同。
创建软链接是指向另一个文件的特殊文件，这种文件的数据部分仅包含它要链接文件的路径名。
####c. 为什么不能对目录建立硬链接? 为什么不能跨设备建立硬链接?


- 在传统的UNIX文件系统中，一个目录就是一个包含关联列表的文件。目录文件中的条目是字符串形式的文件名及其对应的唯一文件标识符-- inode号。当一个目标第一次被创建，就会为它创建一个目录项，这其实就是硬链接，当一个子目录被创建时，在其父目录中也创建了一个目录项，这个目录项用于将子目录的名称与新创建inode关联起来。这两个目录项分别将"."，".." 和当前目录及其父目录关联起来。所以，创建一个子目录会创建一个新的硬件链接到其父目录，以及两个对新创建对象（子目录）的硬件链接：一个来自其父目录，另一个来自他自己（"."），也就是说一个目录项的硬链接数最少是2。允许目录的硬链接可能会打破文件系统的有向无环图结构，可能创建目录循环，这可能会导致fsck以及其他一些遍历文件树的软件出错。
<pre><code style="color: #000000;">hy@debian:~/Documents$ ln docker docker2
ln: ‘docker’: hard link not allowed for directory
</pre></code>


- 硬连接是不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。
####d. 当A不存在时, 能否建立A的硬链接B? 能否建立A的软链接B?
在A不存在时不能建立A的硬链接B，但是可以建立A的软连接B，它只是记录了A的文件路径，当我们将A放到对应的路径下面后，访问B的时候就会访问到A。
###6. 文件的权限:
####a. /usr/bin下某命令abc的文件权限为744, 非属主应如何运行这个命令?
要想让非属主用户运行该命令则需要以下操作：
<pre><code style="color: #000000;">chmod o+x /usr/bin/文件名
</pre></code>
####b. 对于目录, 文件权限里的w和x各是什么意思?
<p>W:对目录来说，具有删除、移动目录内文件的权限。</p>
<p>X:对目录了来说该用户具有进入目录的权限。</p>
####c. rwsr-xr-x代表什么权限?
用户本身具有读写以及root用户才可以执行的权限，用户组具有可读、可执行权限，其他用户具有可读、可执行权限。
###7. Linux系统启动:
####a. 请参考各种文档, 综述Linux系统启动过程中发生了什么事情.
查阅资料Linux的启动过程大致可分为以下步骤：

- 加载 BIOS 的硬件信息；
- 读取 MBR 的 Kernel Loader开机信息；
- 加载 Kernel 的操作系统核心信息；
- Kernel 执行 init 程序并取得 run-level 信息；
- init 执行 /etc/rc.d/rc.sysinit 档案；
- 启动核心的外挂式模块 (/etc/modules.conf)；
- init 执行 run-level 的各个批次档( Scripts )；
- init 执行 /etc/rc.d/rc.local 档案；
- 执行 /bin/login 程序；
- 登入之后开始以 Shell 控管主机。
####b. Debian系统服务启动的顺序是如何被确定的?


- 系统服务的启动脚本一般放在/etc/init.d目录下。
- 不同的开机模式，则分别对应到/etc/rcx.d目录下其实/etc/rcx.d上的文件，一般都是链接到/etc/init.d目录下的对应文件的。
- /etc/rcx.d下的文件名，是以S+数字或K+数字打头的，这里的S表示启动，K表示关闭，数值其后面的数值则表示服务启动或服务退出时的次序。

####c. 运行级别是什么东西?
简单的说，运行级别就是操作系统当前正在运行的功能级别。这个级别从1 到6 ，具有不同的功能。在不同的操作系统中是不一样的，在redhat/centos中这些级别在/etc/inittab 文件里指定。这个文件是init 程序寻找的主要文件，最先运行的服务是那些放在/etc/rc.d 目录下的文件。大多数的Linux 发行版本中，启动脚本位于 /etc/rc.d/init.d。这些脚本被ln 命令来连接到 /etc/rc.d/rcn.d 目录(这里的n 就是运行级0-6)。
<pre><code style="color: #000000;">运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
运行级别2：多用户状态(没有NFS)
运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
运行级别4：系统未使用，保留
运行级别5：X11控制台，登陆后进入图形GUI模式
运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动
</pre></code>

- 我们可以通过安装sysv-rc-conf这个软件来进行设置我们服务的启动级别
<pre><code style="color: #000000;">sudo apt-get install sysv-rc-conf
</pre></code>
####d. 单用户模式是什么东西?
单用户模式是指：单用户工作状态，root权限，用于系统维护，禁止远程登陆，这种模式一般用于系统管理员在系统发生异常的时候进入修改一些配置使用。
###8. 管道与重定向:
####a. 重定向中的0, 1, 2各代表什么意思?
<pre><code style="color: #000000;">0表示标准输入
1表示标准输出
2表示标准错误输出
>默认为标准输出
>2>&1 将标准错误输出重定向到标准输入
&>file 将标准输出和标准错误输出都重定向到文件file中
</pre></code>

####b. 请简述管道是如何让程序能够互相协同工作的.
linux shell中管道发挥的作用是文件描述符重定向，例如 prog1 | prog2 | prog3，管道会将prog1的标准输出重定向为prog2的标准输入，将prog2的标准输出重定向为prog3的标准输入，prog1的标准输入和 prog3的标准输出并没有改变。比如命令"ps -ef  |grep "ssh"将ps命令的标准输出内容作为grep的输入，两个命令的组合的只输出关于ssh进程的信息。
####c. 命名管道是什么东西? 如何创建一个有名管道?
<p>“命名管道”又名“命名管线”（Named Pipes），是一种简单的进程间通信（IPC）机制，命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信。</p>
<p>有名管道实现了无亲缘关系间的通信，原理是fifo提供了一个路径名与之关联，让fifo的文件存于系统中，只要知道该文件路径，就可以进行访问。fifo指代（fist in, fist out），即按照先进先出的工作。</p>

<p>fifo 创建</p>
<pre><code style="color: #000000;">#include \<sys/types.h\>
\#include \<sys/stat.h\>

int mkfifo(const char * pathname, mode_t mode);

参数：
pathname 为路径名，创建管道的名字
mode 为创建fifo的权限
</pre></code>

例1，该程序让子进程执行了ls-l命令，并将执行结果写入有名管道，父进程从该管道中读出执行结果，输出到屏幕，最后删除该有名管道的文件
<pre><code style="color: #000000;">#include \<stdio.h\>
\#include \<stdlib.h\>
\#include \<sys/types.h\>
\#include \<fcntl.h\>
\#include \<string.h\>
\#include \<sys/stat.h\>
\#include \<errno.h\>
\#include \<unistd.h\>

\#define FIFO2 "/tmp/fifo.2"
int main(int argc, int ** argv)
{
    int readfd,writefd;
    pid_t pid;
    char buf[1001];
    //建立有名管道    S_IFIFO|0666指名创建有名管道且存取权限为0666，即创建者/其同组用户/其他用户均可读可写
    if(mkfifo(FIFO2, S_IFIFO|0666)< 0)
    {
        printf("mkfifo2 error");
        exit(1);
    }
    if((pid = fork()) == 0) //创建进程 子进程写
    {
        writefd = open(FIFO2, O_WRONLY);  //打开管道以写方式
        dup2(1, writefd); //定向输出的东西到管道输入
        execlp("ls", "ls", "-l", NULL);//子进程执行ls -l 命令， 即执行结果到有名管道中
    }

    readfd = open(FIFO2, O_RDONLY);//打开管道以读方式
    while(read(readfd, buf, 1000) != 0)
    {
        printf("%s", buf);    //读出管道东西到屏幕
    }
    waitpid(pid, NULL, 0);//等待子进程结束
    close(readfd);
    close(writefd);
    unlink(FIFO2);//删除FIFO2文件
    exit(0);
}

注：有名管道需要用open函数打开以后使用，如果以读方式打开，会阻塞到有写方打开管道，同样以写方式打开会阻塞到以读方式打开，若同时打开读写，则不会阻塞，在该程序中一定会先执行子进程，因为父进程读管道时，管道中没有数据，也会阻塞read到有write写入到管道中.
</pre></code>
####d. 请简述一个场景, 其中使用命名管道是必要的.
linux中当我们把一个程序的输出直接连接到另一个程序的输入的时候，我们可以使用命名管道提供两个进程之间的通讯。
###9. 用户管理:
####a. 新用户创建时, 如果选择自动创建用户home目录, 此时home目录中自动生成的内容是从哪儿来的?
是/etc/skel/目录下的隐藏文件
####b. 删除一个用户时, 系统会执行那些操作, 改变哪些文件?
在删除一个用户时，系统会删除用户信息，并删除/etc/passwd,/etc/group,/etc/shadow中有关用户的信息，在linux中我们使用userdel删除一个用户时，加-r参数会将用户的HOME目录下的档案会一并删除，其他位置的档案信息也会一一找出并删除，例如/var/mail/用户名下的邮件。
####c. 用户的密码存储在哪个文件里?
linux用户密码存储在/etc/shadow,/etc/shadow信息由passwd命令根据/etc/passwd中的数据自动产生。
####d. 禁止用户登录的方式有哪些?


- 1.修改用户配置文件/etc/shadow，将第二栏设置为“*”，那么该用户就无法登录。但是使用这种方式会导致该用户的密码丢失，也就是当你再次允许他登录的时候，你还得让他重新设置密码。
- 2.使用命令usermod
<pre><code style="color: #000000;">usermod -L hy ##Lock 帐号hy
usermod -U hy ##Unlock 帐号hy
</pre></code>

- 3.通过修改shell类型，使用（usermod -s /sbin/nologin hello）这条命令修改用户不能登陆，或者直接在/etc/passwd这个文件中修改最后一列为/sbin/nologin。
- 4.在/etc目录下建立一个nologin文档，在该文件中存在的用户（除了root）都无法登录
####e. 如何踢用户下线.
<pre><code style="color: #000000;">root@debian:~# w		#查看当前在线用户
 12:59:05 up 11:18,  3 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
hy       pts/0    192.168.31.1     07:38    5:17m  2.06s  0.02s sshd: hy [priv]     
hy       pts/1    192.168.31.1     07:41    3:41m  0.10s  0.10s -bash
hy       pts/2    192.168.31.1     07:42    0.00s  1.34s  0.01s sshd: hy [priv]     
root@debian:~# pkill -kill pts/0  或者 pkill -kill -t pts/0踢掉一个在线用户
</pre></code>
###10. apt-get与Debian软件包管理:
####a. 请尽量详细地描述在执行 apt-get update && apt-get install mtr 的过程中, apt-get是如何工作的.
执行 apt-get update && apt-get install mtr 的过程中，apt会访问/etc/apt/sources.list内的地址，并在该网站中找到对应系统的包信息进行更新，更新完成后会检查这个软件是否已经被安装，如果没有安装，再进行安装mtr这个软件，例如我的操作系统是debian，网站是deb http://mirrors.163.com/debian/ jessie main non-free contrib，那么当我们执行命令安装时，他就会对应的访问http://mirrors.163.com/debian/对应目录下的packages.gz，这个文件是服务器上软件包及其依赖关系的清单，并且用gzip压缩过了。apt-get update使用这个清单来确定能够获得哪些补充的软件包且他的内容会被保存在/var/lib/apt/lists内，通过访问这个lists确定该软件是否已安装，是否是最新版本，依赖关系是否满足，从而确定要更新内容，并进行更新，其安装过程主要是由dpkg来完成。
####b. 怎么升级一个软件.
<pre><code style="color: #000000;">sudo apt-get install 软件包名
如果有更新则会自动升级。
</pre></code>
####c. apt-get install 是如何处理已安装但需要升级的软件(例如openssh)的升级的?
它会将系统中的软件包与需要升级的版本进行对比，如果版本过低，则先从源服务器下载更新软件包及它所需要的一些更新的依赖性，下载完成后先安装依赖性，然后安装软件包，最后清除下载的软件包。
####d. apt-cache
<pre><code style="color: #000000;">apt-cache stats         # 显示系统软件包的统计信息
apt-cache search <pkg>        # 使用关键字pkg搜索软件包  
apt-cache show   <pkg_name>   	 # 显示软件包pkg_name的详细信息  
apt-cache depends <pkg>       # 查看pkg所依赖的软件包  
apt-cache rdepends <pkg>      # 查看pkg被那些软件包所依赖  
</pre></code>
###11. 安全习惯:
####a. 请从攻击者的角度来讲述有多少种方式来获得公用wifi中的其他用户的信息.


- 可以通过wireshark进行局域网抓包的方式获得wifi用户的信息
- 可以通过先运行net view，然后再运行arp -a然后获得用户信息
- 可以通过ping net view列出的用户名得到用户的信息
- 另外一种就是通过猜测，然后字典暴力破解wifi所对应的路由设备的用户名密码，从而得到所有用户的信息

####b. 请解释公私钥加密的原理, 并解释应该如何保管和使用ssh私钥.
<p>所谓的公钥认证，实际上是使用一对加密字符串，一个称为公钥(public key)，任何人都可以看到其内容，用于加密；另一个称为密钥(private key)，只有拥有者才能看到，用于解密。通过公钥加密过的密文使用密钥可以轻松解密，但根据公钥来猜测密钥却十分困难。</p>
<pre><code style="color: #000000;">ssh-keygen -t rsa -f ~/.ssh/id_rsa.work -C "Key for Work stuff"		#生成秘钥对
ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C "Key for GitHub stuff"
</pre></code>
这个命令直接通过-f参数指定了密钥和公钥的文件名，比如-f ~/.ssh/id_rsa.work，其生产的密钥为~/.ssh/id_rsa.work，公钥为~/.ssh/id_rsa.work.pub，生成好了公钥和密钥后，把公钥文件中的内容追加到~/.ssh/authorized_keys文件的末尾，注意追加前authorized_keys文件的末尾需要有个换行符。追加后的效果可能是这样的：
<pre><code style="color: #000000;">ssh-rsa AAAAB3NzaC1yc2EAAaaaaaaupeyE1NMMrb121244DwhwFLsPFiFrFb1QUwQtX2m/YSi8ELn3Vga/5AhfKKPWG+nOczWZxi0XguiyAslRiiowXaUjBYei5NHHBcAy+GiZWs4u8h3ZU7uGvwmQlqHf8tQ/I0J1RNR6nQ8Ra9882398akk23h9Hhp63EagSbpkefg7qScroq0+VZ2yfLyjUCLgxhb+Eah+r9EqQ4l%HEF;asd8hLQw449W1SzKz3hCwxFAJFKbj/n+J50vNXB3fLNeTNiq@OOIkn324n802Do5jIZGFzNrYsIRFbJVbHvIsodyXDmz6Qbqlx87xmEQ== admaaa@163.com
ssh-rsa AAAAB3NzaC1yc2EAAAaa2#@8923n(&@hfg2-hg9002nkglsdfPCBUhDN185+jyoJQRwLImRr6IOwh/LSBS1N22pO#NG3434ng90u32n@0)@#NKDLHWO:@_jqtUIBr8UzWzliM5Zcn9U/DjSjuAiP/SFg1JEoXfWSFToWQpYNbGS9VFwU83MH1iGGDUeaeHY5mAMWy57ym/+Jm/hPs1I3E+OtDT9+K1RyIGr44Ur7aWpKZ/PMgiuPUc6qfGFVP4xvRw== myyyy@gmail.com
</pre></code>
<p>也可直接使用ssh-copy-id这个命令来进行秘钥的分发。</p>
<p>当有多个ssh密钥需要管理时，一定要修改config文件的权限，否则你配置后仍然时无效的</p>
<pre><code style="color: #000000;">touch ~/.ssh/config
chmod 600 ~/.ssh/config
</pre></code>
~/.ssh/config文件的内容为：
<pre><code style="color: #000000;">Host *.workdomain.com
    IdentityFile ~/.ssh/id_rsa.github
    User git
Host *.workdomain.com
    IdentityFile ~/.ssh/id_rsa.work
    User lee

chmod 600 ~/.ssh/config		#并且修改权限为600
</pre></code>
####c. 请解释ssh agent forward的工作原理, 并从攻击者的角度来讲述这一工作原理有没有可利用之处.


- 我们在使用ssh-keygen生成密钥对的时候一般默认回车就ok了，如果我们需要更强的安全性，在设置的时候就需要输入密码，但是对不同的主机建立ssh加密认证的时候我们可能输入的密码不相同，这时我们会差生很多密码，这个时候我们在每次登陆远程主机的时候都需要输入passphrase，感觉记录这些密码也特别不方便。


- 为解决每次登陆远程机器都需要输入passphrase的问题，ssh-agent被引入了。ssh-agent启动后，可通过ssh-add将私钥加入agent. ssh-add会提示用户输入passphrase以解密私钥，然后将解密后的私钥纳入agent管理。agent可同时管理多个私钥。

- 从安全的角度来说如果黑客就算获得了公钥和私钥，在进行暴力破解的时候也非常困难，因为这里有多个不同的passphrase。
####d. 列举你所知道的密码管理工具及其工作方式, 并从攻击者角度来讲述这些工具有什么安全隐患.
- 我们有时候会看到很多人习惯使用记事本或者云笔记记录一些主机或者一些账号密码，这样其实很不安全，只要攻击者拿到宿主机的密码或者用户的云笔记的账户密码，则所有的密码都被暴漏。

- 为了安全起见，我会使用一些密码管理工具进行管理，我平时使用的是keypass进行密码管理，这个工具相对来说是比较安全的，它不同于其它密码管理软件需要剪切并粘贴或拖曳操作来输入你的密码，KeyPass 输入密码只需要你按下自定义热键。它同样可以工作在任何一款浏览器或应用程序(共享软件)，但是如果攻击者将你设置完成的keypass复制一份出来，他也可以在自己的电脑上通过keypass进行登录想要登录的服务器或网站等等。

####e. https全站加密有什么优势和劣势?
HTTPS协议的主要作用可以分为两种：

- 优势：
	- HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全；
	- 另一种就是确认网站的真实性。
- 缺点：
	- 1、HTTPS协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
	- 2、HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全。特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。
####f. 请阐述你对最小权限原则的理解.
<p>最小权限原则要求系统只授予主体必要的权限，而不要过度授权，这样能有效地减少系统、网络、应用、数据库出错的机会。</p>
<p>比如在Linux系统中，一种良好的操作习惯是使用普通账户登录，在执行需要root权限的操作时，再通过sudo命令完成。这样能最大化地降低一些误操作导致的风险；同时普通账户被盗用后，与root帐户被盗用所导致的后果是完全不同的。</p>
###12. 分区和挂载:
####a. 将所有的目录置于同一个分区有什么优势和劣势?
- 优势：方便管理，可在同一个分区中对文件进行操作，公用该分区的存储空间
- 劣势：当该分区坏掉后所有的文件都将不复存在，安全性不高，所以我们常常会看到一块硬盘存在很多分区
####b. LVM是什么?
LVM是逻辑盘卷管理的简称，它是Linux环境下对磁盘分区进行管理的一种机制LVM是建立在硬盘和 分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volumegroup），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logicalvolumes），并进一步在逻辑卷组上创建文件系统。
####c. 从安全角度考虑, 哪些分区应适当限制大小?


###13. 信号机制:
####a. 请简述kill命令的原理.
<p>kill命令的工作原理是，向Linux系统的内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。比如在top命令中，我们看到系统运行许多进程，有时就需要使用kill中止某些进程来提高系统资源。在讲解安装和登陆命令时，曾提到系统多个虚拟控制台的作用是当一个程序出错造成系统死锁时，可以切换到其它虚拟控制台工作关闭这个程序。此时使用的命令就是kill，因为kill是大多数Shell内部命令可以直接调用的。</p>
####b. 请简述nohup命令的原理.
<p>nohup命令的原理：当启动作业的终端被称为这个作业的控制终端。当您注销时，一些 shell（缺省情况下不是 bash）将向这些后台作业传送 SIGHUP 信号，从而导致这些进程退出。为了保护进程以免产生这种行为，当您启动进程时，使用 nohup。</p>
####c. 如何在bash脚本中处理用户的Ctrl-C?
<p>当用户按下<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出SIGINT信号。默认动作为终止进程。 如果用户需要按下组合键后继续后续程序的执行我们可以可以将运行进程打入后台，<Ctrl+C>也不会结束。</p>
###14. SUID机制与sudo:
####a. 建简述SUID机制存在的意义.
<p>SUID机制存在的意义：让本来没有相应权限的用户运行这个程序时，可以访问没有权限访问的资源。</p>
<p>passwd就是一个很鲜明的例子SUID的优先级比SGID高，当一个可执行程序设置了SUID，则SGID会自动变成相应的egid。</p>
<p>我们可以使用：chmod u+s filename来给文件加SUID特殊权限</p>
####b. sudo的主配置文件路径是什么? 应如何更新这个文件?
<p>sudo的主配置文件路径：/etc/sudoers</p>
更新这个文件：
<pre><code style="color: #000000;">%sudo   ALL=(ALL:ALL) ALL
%test      ALL=(ALL:ALL) ALL	#前面加%指后面接的是一个群组,格式和单用户授权一样
hy      ALL=(ALL:ALL) ALL		#我们可以在这里设置我们需要的更新
</pre></code>
####c. 如果需要在shell脚本中通过sudo调用某个命令或者程序, 应如何配置sudo?
- visudo单用户授权
<pre><code style="color: #000000;">root@debian:~# visudo
......
root    ALL=(ALL:ALL) ALL	#<==找到这一行
hy      ALL=(ALL:ALL) ALL	#<==新增这行！则hy用户通过sudo拥有所有的权限
......
</pre></code>
语法解释：
<pre><code style="color: #000000;">root		ALL=(ALL:ALL) 			ALL
使用者账号	登入者的来源主机名=(可切换的身份)	可下达的指令
</pre></code>
详细解释：
<pre><code style="color: #000000;">使用者帐号	代表哪个用户使用sudo的权限
来源主机名称	指定信任用户，即根据w查看[使用者帐号]的来源主机
可切换的身份	代表可切换的用户角色，和sudo -u结合使用，默认是切换为root.
可下达的指令	用于权限设置，也可使用!来表示不可执行的命令
</pre></code>

举例：
<pre><code style="color: #000000;">root@debian:~# visudo
hy ALL=(root) !/usr/bin/passwd,!/usr/bin/passwd root
允许hy用户通过sudo来修改所有其它用户的密码，但不能修改root的密码
</pre></code>
- visudo利用群组授权：
<pre><code style="color: #000000;">root@debian:~# visudo
%test	ALL=(ALL)	ALL
在最左边加上 % ，代表后面接的是一个群组,格式和单用户授权一样

root@debian:~#usermod -a -G root test <==将test加入root的组中
任何加入test这个群组的使用者，就能够使用 sudo 切换任何身份来操作任何指令
</pre></code>

- 不需要密码即可使用sudo：
<pre><code style="color: #000000;">......
%wheel ALL=(ALL) NOPASSWD: ALL
在指令处加入NOPASSWD:ALL即可
</pre></code>

- visudo利用别名授权
<pre><code style="color: #000000;">root					ALL=				(ALL)		ALL
使用者账号			登入者的来源主机名		可切换的身份		可下达的指令
User_Alias 			Host_Alias CSNETS = 		Runas_Alias OP = 	Cmnd_Alias PRINTING = 
FULLTIMERS = millert,		128.138.243.0, 			root, operator	        /usr/sbin/lpc, /usr/bin/lprm
mikef, dowdy			128.138.204.0/24, 
				128.138.242.0
</pre></code>
例如：
<pre><code style="color: #000000;">root@debian:~# visudo
User_Alias ADMPW = pro1,pro2, pro3, myuser1, myuser2 #配置用户别名ADMPW
Cmnd_Alias ADMPWCOM =!/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root  #配置命令别名ADMPWCOM
ADMPW ALL=(root) ADMPWCOM #指定用户别名里的成员，拥有命令别名里的权限
</pre></code>
####d. 怎样将某个高权限程序一部分的功能开放给sudo? 例如能让用户改子网掩码, 而不让他修改机器ip地址.
<pre><code style="color: #000000;">root@debian:~# visudo
hy      ALL=(root) /sbin/ifconfig, !/sbin/ifconfig eth0 [0-9]*,/sbin/ifconfig eth0 netmask *
</code>pre></pre>code>

###15. 文件传输: scp vs rsync:
####a. 对比默认参数下, 两种方式消耗的系统资源情况.
<p>scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p>
####b. 在服务器端存在对应服务的条件下, 哪种方式的传输是有加密的?
scp传输默认是加密的，rsync我们也可以对其进行配置加密，通过修改配置文件实现。
####c. 请阐述在scp和rsync的具体适用场景, 即在什么时候应该适用scp而不是rsync,在什么时候应该适用rsync而不是scp.


- scp适合完全备份的时候使用，当我们使用远程shell方式的时候，建议使用scp，用户验证由ssh负责；
具体实现：

<pre><code style="color: #000000;">复制文件：
scp local_file remote_username@remote_ip:remote_folder
复制目录：
scp -r local_folder remote_username@remote_ip:remote_folder

从远程到本地：
scp root@remote_ip:remote_file local_file
scp -r remote_ip:remote_folder local_folder
</pre></code>

- 还有一种方式C/S方式，即客户端连接远程rsync服务器，用户验证由rsync服务器负责。

